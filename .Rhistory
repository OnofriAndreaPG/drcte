mapping = aes(x = timeAf, y = propCum)) +
facet_wrap(~ curveCode, ncol = 8)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
tmp <- subset(Buk, curveCode == "4:-1.4")
tmp
obj <- lm(propCum ~ 1, data = tmp)
summary(obj)
vcov(obj)
solve(vcov(obj))
tmp <- vcov(obj)
tmp <- vcov(obj)
tmp[tmp==0]
tmp[tmp==0] <- 1E-6
nlsFit$hessian <- matrix(solve(tmp)) * 2 * summary(mod2)$sigma^2
nlsFit$hessian <- matrix(solve(tmp)) * 2 * summary(obj)$sigma^2
matrix(solve(tmp)) * 2 * summary(obj)$sigma^2
source("~/Documents/_DBXAndrea/Dropbox/_Lavoro/MyUtilities/RPackages/drcte/R/as.drc.R")
source("~/Documents/_DBXAndrea/Dropbox/_Lavoro/MyUtilities/RPackages/drcte/R/as.drc.R")
rm(list = ls())
Buk <- read_xlsx("docs/Buk_Update.xlsx", sheet = "H2") %>%
mutate(timeAf = as.numeric(timeAf),
curveCode = factor(factor(temp):factor(water)))
Buk
Buk_mean <- aggregate(propCum ~ curveCode + timeAf,
mean, data=Buk)
head(Buk_mean, n=6)
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
facet_wrap(~ curveCode, ncol = 8)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
mod$data
mod$parNames
obj <- lm(propCum ~ 1, data = tmp)
# This function transform an lm object into a drc object
# All slots are ok (19/3/2022)
nlsFit <- list()
nlsFit$par <- coef(obj)
nlsFit$value <- deviance(obj) # as.numeric(logLik(obj))
nlsFit$counts <- NULL
obj <- lm(propCum ~ 1, data = tmp)
tmp <- subset(Buk, curveCode == "4:-1.4")
tmp
mod <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.2())
obj <- lm(propCum ~ 1, data = tmp)
# This function transform an lm object into a drc object
# All slots are ok (19/3/2022)
nlsFit <- list()
nlsFit$par <- coef(obj)
nlsFit$value <- deviance(obj) # as.numeric(logLik(obj))
nlsFit$counts <- NULL
nlsFit$convergence <- TRUE
nlsFit$message <- NULL
tmp <- vcov(obj)
tmp[tmp==0] <- 1E-6
nlsFit$hessian <- matrix(solve(tmp)) * 2 * summary(obj)$sigma^2
nlsFit$method <- "Parametric"
# varParm
varParm <- NULL
## curve function
pfFct <- function(obj)
{
plotFct <- function(dose)
{
if (is.vector(dose))
{
lenPts <- length(dose)
} else {
lenPts <- nrow(dose)
}
curvePts <- predict(obj, newdata = data.frame(dose))
curvePts <- matrix(curvePts, lenPts, 1)
return(curvePts)
}
return(plotFct)
}
plotFct <- pfFct(obj)
# summary
sumVec <- c(NA, NA, NA, deviance(obj), obj$df.residuals, length(obj$residuals))
# start
startVec <- NULL
names(obj$coefficients
)
obj <- as.drc(obj)
obj$parNames
tmp <- subset(Buk, curveCode == "15:-1.4")
tmp
mod <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.2())
tmp <- subset(Buk, curveCode == "25:-1.4")
tmp
mod <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.2())
obj <- lm(propCum ~ 1, data = tmp)
obj <- as.drc(obj)
mod$parNames
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
# Alcune incoerenze
tmp <- subset(Buk, curveCode == "20:-0.2")
mod <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.3())
plot(mod)
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tmp <- subset(Buk, curveCode == "20:-0.2")
mod1 <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.3())
plot(mod1)
summary(mod1)
mapping = aes(x = timeAf, y = CDF) +
ggplot() +
geom_point(data = tab2,
mapping = aes(x = timeAf, y = CDF)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
tmp <- subset(Buk, curveCode == "20:-0.2")
tmp
as.data.frame(tmp)
tmp <- subset(Buk, curveCode == "4:-0.2")
as.data.frame(tmp)
mod1 <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.3())
obj <- lm(propCum ~ 1, data = tmp)
obj <- as.drc(obj)
obj$logDose
obj$dataList
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = tab2,
mapping = aes(x = timeAf, y = CDF)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
tmp <- subset(Buk, curveCode == "20:-0.2")
as.data.frame(tmp)
as.data.frame(tmp)
rm(list = ls())
Buk <- read_xlsx("docs/Buk_Update.xlsx", sheet = "H2") %>%
mutate(timeAf = as.numeric(timeAf),
curveCode = factor(factor(temp):factor(water)))
Buk
Buk_mean <- aggregate(propCum ~ curveCode + timeAf,
mean, data=Buk)
head(Buk_mean, n=6)
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
facet_wrap(~ curveCode, ncol = 8)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
rm(list = ls())
Buk <- read_xlsx("docs/Buk_Update.xlsx", sheet = "H2") %>%
mutate(timeAf = as.numeric(timeAf),
curveCode = factor(factor(temp):factor(water)))
Buk
Buk_mean <- aggregate(propCum ~ curveCode + timeAf,
mean, data=Buk)
head(Buk_mean, n=6)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
tmp <- subset(Buk, curveCode == "15:-0.4")
as.data.frame(tmp)
mod1 <- drmte(nSeeds  ~ timeBef + timeAf,
data = tmp,
fct = LL.3())
rm(list = ls())
Buk <- read_xlsx("docs/Buk_Update.xlsx", sheet = "H2") %>%
mutate(timeAf = as.numeric(timeAf),
curveCode = factor(factor(temp):factor(water)))
Buk
Buk_mean <- aggregate(propCum ~ curveCode + timeAf,
mean, data=Buk)
head(Buk_mean, n=6)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
rm(list = ls())
Buk <- read_xlsx("docs/Buk_Update.xlsx", sheet = "H2") %>%
mutate(timeAf = as.numeric(timeAf),
curveCode = factor(factor(temp):factor(water)))
Buk
Buk_mean <- aggregate(propCum ~ curveCode + timeAf,
mean, data=Buk)
head(Buk_mean, n=6)
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
facet_wrap(~ curveCode, ncol = 8)
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF), col = "red") +
facet_wrap(~ curveCode, ncol = 8)
quantile(mod)
quantile(mod, probs = c(0.3))
tmp <- subset(Buk, curveCode == "30:0")
tmp
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = tmp,
fct = LL.3())
mod$fct
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
quantile(mod, probs = c(0.3))
mod$separateFit
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
ggplot() +
geom_point(data = Buk_mean,
mapping = aes(x = timeAf, y = propCum)) +
geom_line(data = tab$plotFit,
mapping = aes(x = timeAf, y = CDF),
col = "red") +
facet_wrap(~ curveCode, ncol = 8)
mod$separateFit
pr <- lapply(mod$separateFit, quantile)
mod$separateFit[[1]]
str(mod$separateFit)
mod$separateFit$`30:0`
quantile(mod$separateFit$`30:0`, probs = 0.3)
quantile(mod$separateFit$`4:-1.4`, probs = 0.3)
object <- mod$separateFit$`4:-1.4`
# Get information from the call
interval <- match.arg(interval)
reference <- match.arg(reference)
choice <- object$fct$name
choice
object$fct
LL.3()
LL.3
llogistic
loglogistic
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
quantile(mod$separateFit$`4:-1.4`, probs = 0.3)
object$fct$name
object <- mod$separateFit$`4:-1.4`
object$fct$name
choice <- object$fct$name
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
object <- mod$separateFit$`4:-1.4`
quantile(object, probs = c(0.3))
object <- mod$separateFit$`4:-1.4`
quantile(object, probs = c(0.3))
object$fct$"edfct"
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
object <- mod$separateFit$`4:-1.4`
quantile(object, probs = c(0.3))
object$fct$"edfct"
## Retrieving relevant quantities
EDlist <- object$fct$"edfct"
EDlist
object$"indexMat"
object$"parmMat"
strParm0 <- sort(colnames(object$"parmMat"))
curveNames <- colnames(object$"parmMat")
quantile(mod$separateFit$`30:-0.4`, probs = 0.3)
object <- mod$separateFit$`30:-0.4`
object$indexMat
# Code for basic fitting and plotting
devtools::load_all()
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
quantile(mod$separateFit$`4:-0.4`, probs = 0.3)
object <- mod$separateFit$`4:-0.4`
object$indexMat
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
object <- mod$separateFit$`4:-0.4`
object$indexMat
object
object$indexMat
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
mod$separateFit$`4:-0.4`
object <- mod$separateFit$`4:-0.4`
object$indexMat
object$parNames
source("~/Documents/_DBXAndrea/Dropbox/_Lavoro/MyUtilities/RPackages/drcte/R/as.drc.R")
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
tab <- plotData(mod)
tab1 <- tab$plotFits
tab2 <- tab$plotPoints
quantile(mod$separateFit$`4:-0.4`, probs = 0.3)
object <- mod$separateFit$`4:-0.4`
object$indexMat
class(object)
source("~/Documents/_DBXAndrea/Dropbox/_Lavoro/MyUtilities/RPackages/drcte/R/as.drc.R")
# Code for basic fitting and plotting
devtools::load_all()
mod <- drmte(nSeeds ~ timeBef + timeAf,
data = Buk,
fct = LL.3(), curveid = curveCode,
separate = T)
summary(mod)
quantile(mod$separateFit$`4:-0.4`, probs = 0.3)
object <- mod$separateFit$`4:-0.4`
class(object)
object$indexMat
indexMat <- object$"indexMat"
parmMat <- object$"parmMat"
strParm0 <- sort(colnames(object$"parmMat"))
indexMat
parmMat
strParm0
curveNames <- colnames(object$"parmMat")
curveOrder <- 1:length(curveNames)
strParm0 <- curveNames[curveOrder]
indexMat <- indexMat[, curveOrder, drop = FALSE]
parmMat <- parmMat[, curveOrder, drop = FALSE]
strParm <- strParm0
vcMat <- vcov.(object, ...)
## Defining vectors and matrices
ncolIM <- ncol(indexMat)
indexVec <- 1:ncolIM
#    lenEB <- ncolIM
lenPV <- length(respLev)  # used twice below
noRows <- ncolIM * lenPV
dimNames <- rep("", noRows)  # lenEB*lenPV, 2)
respLev <- 0.5
#    lenEB <- ncolIM
lenPV <- length(respLev)  # used twice below
noRows <- ncolIM * lenPV
dimNames <- rep("", noRows)  # lenEB*lenPV, 2)
EDmat <- matrix(0, noRows, 2)  # lenEB*lenPV, 2)
oriMat <- matrix(0, noRows, 2)  # lenEB*lenPV, 2)
## Calculating estimates and estimated standard errors
rowIndex <- 1
lenIV <- length(indexVec)
dEDmat <- matrix(0, lenPV * lenIV, nrow(vcMat))
vcov(object)
vcMat <- vcov(object)
dEDmat <- matrix(0, lenPV * lenIV, nrow(vcMat))
dEDmat
EDeval <- EDlist(parmChosen, respLev[j], reference = reference, type = type, ...)
quantile(mod$separateFit$`4:-0.4`, probs = 0.3)
?quantile.drcte
# Code for basic fitting and plotting
devtools::load_all()
quantile(mod$separateFit$`4:-0.4`, probs = 0.3)
